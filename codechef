contest 198 ques 3

Currency Exchange
Chef currently has 
A
1
A 
1
​
  gold coins and 
B
1
B 
1
​
  silver coins with him.

He can perform the following three types of transformations:

Pay 
1
1 gold coin and receive 
5
5 silver coins.
This can only be done if he has at least one gold coin.
Pay 
5
5 silver coins and receive 
1
1 gold coin.
This can only be done if he has at least five silver coins.
Discard one gold coin and one silver coin.
This can only be done if he has at least one gold coin and at least one silver coin.
Is it possible, using these transformations, for Chef to end up with exactly 
A
2
A 
2
​
  gold coins and 
B
2
B 
2
​
  silver coins?

Input Format
The first line of input will contain a single integer 
T
T, denoting the number of test cases.
The first and only line of each test case contains 
4
4 space-separated integers 
A
1
,
B
1
,
A
2
,
A 
1
​
 ,B 
1
​
 ,A 
2
​
 , and 
B
2
B 
2
​
  — the initial and target number of gold and silver coins.
Output Format
For each test case, output the answer on a single line: 
YES
YES if it's possible to reach 
A
2
A 
2
​
  gold and 
B
2
B 
2
​
  silver coins, and 
NO
NO otherwise.

Each character of the output may be printed in either uppercase or lowercase, i.e. the strings 
NO
,
No
,
nO
,
NO,No,nO, and 
no
no will all be treated as equivalent.


my solution


#include <bits/stdc++.h>
using namespace std;

const int MAX = 1001;
bool visited[MAX][MAX]; // Global visited matrix

bool solve(int A1, int B1, int A2, int B2) {
    if (A1 == A2 && B1 == B2)
        return true;

    if (A1 < 0 || B1 < 0 || A1 >= MAX || B1 >= MAX)
        return false;

    if (visited[A1][B1]) // Already visited this state
        return false;

    visited[A1][B1] = true; // Mark current state as visited

    bool op1 = false, op2 = false, op3 = false;

    if (A1 >= 1)
        op1 = solve(A1 - 1, B1 + 5, A2, B2); // Gold → Silver

    if (B1 >= 5)
        op2 = solve(A1 + 1, B1 - 5, A2, B2); // Silver → Gold

    if (A1 >= 1 && B1 >= 1)
        op3 = solve(A1 - 1, B1 - 1, A2, B2); // Discard both

    return op1 || op2 || op3;
}

int main() {
    int T;
    cin >> T;

    while (T--) {
        int A1, B1, A2, B2;
        cin >> A1 >> B1 >> A2 >> B2;

        // Reset visited matrix for each test case
        memset(visited, false, sizeof(visited));

        if (solve(A1, B1, A2, B2))
            cout << "Yes" << endl;
        else
            cout << "No" << endl;
    }

    return 0;
}

