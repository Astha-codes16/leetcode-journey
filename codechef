contest 198 ques 3

Currency Exchange
Chef currently has 
A
1
A 
1
​
  gold coins and 
B
1
B 
1
​
  silver coins with him.

He can perform the following three types of transformations:

Pay 
1
1 gold coin and receive 
5
5 silver coins.
This can only be done if he has at least one gold coin.
Pay 
5
5 silver coins and receive 
1
1 gold coin.
This can only be done if he has at least five silver coins.
Discard one gold coin and one silver coin.
This can only be done if he has at least one gold coin and at least one silver coin.
Is it possible, using these transformations, for Chef to end up with exactly 
A
2
A 
2
​
  gold coins and 
B
2
B 
2
​
  silver coins?

Input Format
The first line of input will contain a single integer 
T
T, denoting the number of test cases.
The first and only line of each test case contains 
4
4 space-separated integers 
A
1
,
B
1
,
A
2
,
A 
1
​
 ,B 
1
​
 ,A 
2
​
 , and 
B
2
B 
2
​
  — the initial and target number of gold and silver coins.
Output Format
For each test case, output the answer on a single line: 
YES
YES if it's possible to reach 
A
2
A 
2
​
  gold and 
B
2
B 
2
​
  silver coins, and 
NO
NO otherwise.

Each character of the output may be printed in either uppercase or lowercase, i.e. the strings 
NO
,
No
,
nO
,
NO,No,nO, and 
no
no will all be treated as equivalent.


my solution


#include <bits/stdc++.h>
using namespace std;

const int MAX = 1001;
bool visited[MAX][MAX]; // Global visited matrix

bool solve(int A1, int B1, int A2, int B2) {
    if (A1 == A2 && B1 == B2)
        return true;

    if (A1 < 0 || B1 < 0 || A1 >= MAX || B1 >= MAX)
        return false;

    if (visited[A1][B1]) // Already visited this state
        return false;

    visited[A1][B1] = true; // Mark current state as visited

    bool op1 = false, op2 = false, op3 = false;

    if (A1 >= 1)
        op1 = solve(A1 - 1, B1 + 5, A2, B2); // Gold → Silver

    if (B1 >= 5)
        op2 = solve(A1 + 1, B1 - 5, A2, B2); // Silver → Gold

    if (A1 >= 1 && B1 >= 1)
        op3 = solve(A1 - 1, B1 - 1, A2, B2); // Discard both

    return op1 || op2 || op3;
}

int main() {
    int T;
    cin >> T;

    while (T--) {
        int A1, B1, A2, B2;
        cin >> A1 >> B1 >> A2 >> B2;

        // Reset visited matrix for each test case
        memset(visited, false, sizeof(visited));

        if (solve(A1, B1, A2, B2))
            cout << "Yes" << endl;
        else
            cout << "No" << endl;
    }

    return 0;
}

contest 199 ques 3

Fence Colouring
You have 
N
N fences, and you want to colour them. You have 
N
N total types of colours numbered 
1
,
2
,
…
,
N
1,2,…,N.

Currently, all the 
N
N fences are coloured with the type 
1
1 colour. At the end, you want the 
i
i-th fence to have a colour of 
A
i
A 
i
​
  for every 
1
≤
i
≤
N
1≤i≤N.

You can choose to do one of the following at each minute:

Colour all 
N
N fences at the same time with type 
X
X colour, where you can choose 
X
(
1
≤
X
≤
N
)
X(1≤X≤N).
Colour a specific fence 
i
i with type 
X
X colour, where you can choose 
X
(
1
≤
X
≤
N
)
X(1≤X≤N).
Both of the above operations take only 
1
1 minute to perform. What is the minimum number of minutes needed to colour the entire fence as desired.

Input Format
The first line of input will contain a single integer 
T
T, denoting the number of test cases.
Each test case consists of multiple lines of input.
The first line of each test case contains 
N
N - the number of fences.
The second line contains 
N
N integers - 
A
1
,
A
2
,
…
,
A
N
A 
1
​
 ,A 
2
​
 ,…,A 
N
​
 .
Output Format
For each test case, output on a new line the minimum time needed to colour all 
N
N fences.

#include <bits/stdc++.h>
using namespace std;

int main() {
	// your code goes here
	int T;
	cin>>T;
	
	while(T--)
	{
	    int N;
	    cin>>N;
	    unordered_map<int,int>mpp;
	    int otherval=0;
	    int ans=0;
	    vector<int>A(N);
	    for(int i=0;i<N;i++)
	    {
	        cin>>A[i];
	    }
	    for(int i=0;i<N;i++)
	    {
	        mpp[A[i]]++;
	    }
	    int maxval=INT_MIN;
	    int keyWithMaxValue = -1;
	    for(auto it:mpp)
	    {
	        if(it.second>maxval)
	        {
	            maxval=it.second;
	            keyWithMaxValue=it.first;
	        }
	    }
	    if(maxval==mpp[1])
	    {
	        ans= N-maxval;
	    }
	    else if( keyWithMaxValue!=1 && maxval>1)
	    {
	        otherval=N-maxval;
	        ans=1+otherval;
	    }
	    else if(keyWithMaxValue==1  && maxval>1)
	    {
	        otherval=N-maxval;
	        ans=otherval;
	    }
	    else if(maxval==1)
	    {
	        if (mpp.find(1) != mpp.end())
	        {
	            ans=N-1;
	        }
	        else
	        {
	            ans=N;
	        }
	    }
	    
	    cout<<ans<<endl;
	    
	    
	    
	}

}


OPTIMISED SOLUTION
#include <bits/stdc++.h>
using namespace std;

int main() {
    int T;
    cin >> T;
    while (T--) {
        int N;
        cin >> N;
        unordered_map<int, int> mpp;
        vector<int> A(N);
        for (int i = 0; i < N; i++) {
            cin >> A[i];
            mpp[A[i]]++;
        }

        int maxval = INT_MIN;
        for (auto it : mpp) {
            maxval = max(maxval, it.second);
        }

        int count1 = mpp[1]; // how many already have color 1

        // Option 1: paint all non-1 individually
        int optionA = N - count1;

        // Option 2: global paint to most frequent color, fix rest
        int optionB = 1 + (N - maxval);

        // Minimum of both options
        int ans = min(optionA, optionB);

        cout << ans << "\n";
    }
}

